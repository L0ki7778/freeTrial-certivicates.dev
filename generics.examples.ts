//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////generische Typisierung///////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

function identity<T>(value: T): T {
  return value;
}

const numberResult = identity<number>(42);
const stringResult = identity<string>('Hello');

interface Box<T> {
  content: T;
}

const numberBox: Box<number> = { content: 123 };
const stringBox: Box<string> = { content: 'Test' };


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////Constraints durch extends//////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////


function merge<T, U>(a: T, b: U): T & U {
  return { ...a, ...b };
}

const merged = merge({ name: 'Anna' }, { age: 30 });

interface HasLength {
  length: number;
}

function logLength<T extends HasLength>(item: T): number {
  return item.length;
}

const len1 = logLength('Hello');
const len2 = logLength([1, 2, 3]);



//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////generische Klassen//////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////


class MyStorage<T> {
  private items: T[] = [];

  add(item: T): void {
    this.items.push(item);
  }

  getAll(): T[] {
    return this.items;
  }
}

const numberStorage = new MyStorage<number>();
numberStorage.add(10);
numberStorage.add(20);

const stringStorage = new MyStorage<string>();
stringStorage.add('A');
stringStorage.add('B');


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////Vererbung und Interfaces kombiniert//////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////


interface Repository<T> {
  add(item: T): void;
  getAll(): T[];
}

class BaseRepository<T> implements Repository<T> {
  protected items: T[] = [];

  add(item: T): void {
    this.items.push(item);
  }

  getAll(): T[] {
    return this.items;
  }
}

class UserRepository extends BaseRepository<MyUser> { }

interface MyUser {
  id: number;
  name: string;
}

const users = new UserRepository();
users.add({ id: 1, name: 'Alice' });
users.add({ id: 2, name: 'Bob' });


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////Constrains in Vererbung/////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

interface BaseEntity {
  id: number;
}

class EntityRepository<T extends BaseEntity> {
  private entities: T[] = [];

  add(entity: T): void {
    this.entities.push(entity);
  }

  findById(id: number): T | undefined {
    return this.entities.find(e => e.id === id);
  }
}

interface Product extends BaseEntity {
  name: string;
}

const productRepo = new EntityRepository<Product>();
productRepo.add({ id: 1, name: 'Book' });
productRepo.add({ id: 2, name: 'Phone' });

const found = productRepo.findById(2);
